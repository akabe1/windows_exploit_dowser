#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# Title:
# Windows Exploit Dowser
#
#
# Author:
# Maurizio Siddu
#
#
# Description:
# This script identifies the available public exploits, for Privilege Escalation and 
# Remote Code Execution vulnerabilities, afflicting the target Windows OS specified 
# by user. This obtained comparing the patch level of the target Windows OS 
# (retrieved via "systeminfo" or "wmic qfe list full" commands run on the Windows 
# target OS) with the official MS Windows Bulletin infos.
#
# The list of public exploits is automatically retrieved from the ExploiDB and 
# Metasploit local repo that must be present on the user host. 
# Other exploits could be added manually by editing the dictionary named 
# "CUSTOM_EXPLOITS_DICT" embedded on this script.
#
# Furthermore to decrease the percentage of false negative it is also possible to use 
# the option "--build" in order to create/update a csv file containing the list of some 
# particular ExploitDB scripts which do not have a CVE hardcoded on their source code. 
# The CVEs of this kind of exploits could only be recovered by querying the corresponding 
# pages of the official ExploitDB website.
#
# The list of MS Bulletins is obtained from two official sources:
# *   the new MS Bulletin summary file (starting date 17-03-2017), is available from the 
#     official repository hosted at "https://portal.msrc.microsoft.com/en-us/security-guidance" 
#     and could be downloaded choosing the "--update" command-line option;
# *   the old MS Bulletin summary file, is available from the old MS official repository 
#     hosted at "http://download.microsoft.com", the script provides to automatically 
#     download thi file, if it is not yet present in the working directory.
#
# Various useful information are extracted from the MS Bulletins, and then compared 
# with the information about the Windows target OS submitted in input using the "--systeminfo" 
# option, or alternatively using the combination of "--wmicinfo" and "--target" options. 
# After this phase only the missing security patches in the Windows target OS and the 
# related CVEs are considered.
#  
# Finally the detected missing security patches are associated, by means of the related CVEs, 
# with the available public known exploits previously collected, and the list of potentially 
# working exploits for the missing hotfixes is printed in output. 
# 
# Depending on the selected command-line options,  the user could choose to print out:
# *   all the CVEs related to the missing hotfixes in the Windows target OS ("--verbose" option)
# *   the list of exploits related to software components which could be installed on the Windows target OS ("--greedy" option)
# *   the list of DoS exploits affecting the target OS ("--crash" option)
# 
#
# WARNING: Since the results are based only upon the missing hotfixes, they can be not precise 
# and could incur on some false positives, because the effective running software components on 
# target Windows OS are not known.
#
# This script is heavily inspired by the excellent "Windows_Exploit_Suggester" tool by 
# Sam Bertram (Gotham Digital Science), which seems no longer supported.
#
#
# Improvements:
# See the TODOs in the following source code.
#
# Notes:
# The installation of the Python packages xlrd and BeautifulSoup4 (bs4) is required.
# The script is compatible with Python 2.7 and Python 3.
#   
#
# Copyright (C) 2019  Maurizio Siddu
#
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>




import sys
import os.path
import re
import traceback
import time
import argparse
import json
import xlrd
import csv
import io
from bs4 import BeautifulSoup
from six import iteritems
from six.moves import urllib



# Proof of Sympathy ;-)
LOGO = """                                             
╦ ╦┬┌┐┌  ╔═╗─┐ ┬┌─┐┬  ┌─┐┬┌┬┐  ╔╦╗┌─┐┬ ┬┌─┐┌─┐┬─┐    w w
║║║││││  ║╣ ┌┴┬┘├─┘│  │ ││ │    ║║│ ││││└─┐├┤ ├┬┘    ║ ║
╚╩╝┴┘└┘  ╚═╝┴ └─┴  ┴─┘└─┘┴ ┴   ═╩╝└─┘└┴┘└─┘└─┘┴└─    ╚╦╝
v1.0                                                  ║
"""


MSBULLETIN_URL = 'https://portal.msrc.microsoft.com/api/security-guidance/en-us/excel'
MSBULLETIN_FILE = time.strftime('%Y-%m-%d') + '_msbulletin.xlsx'
OLD_MSBULLETIN_URL = 'http://download.microsoft.com/download/6/7/3/673E4349-1CA5-40B9-8879-095C72D5B49D/BulletinSearch.xlsx'
OLD_MSBULLETIN_FILE = 'old_2017_03_14_msbulletin.xlsx'
EXPLOITDB_URL = 'https://www.exploit-db.com/exploits/'
DEFAULT_EXPLOIDB_DIR = '/opt/exploidb/exploits/'
DEFAULT_META_DIR = '/opt/metasploit-framework/embedded/framework/modules/exploits/windows/'
TODAY = time.strftime('%m/%d/%Y')
NEW_BULLETIN_START_DATE = '03/14/2017' # This is the date of the latest update in the old MS Bulletin file
LOCAL_DB_CSV = 'cve_from_exploitdb_website.csv'


# TODO: mantain updated this Windows OS version/architecture archive 
WINDOWS_HISTORY = {
    'Windows Server 2019':['64-bit'], 'Windows Server 2016':['64-bit'], 'Windows 10':['32-bit', '64-bit', 'armv7', 'arm64'], \
    'Windows Server 2012 R2':['64-bit'], 'Windows 8.1':['32-bit', '64-bit', 'armv7'], 'Windows 8':['32-bit', '64-bit', 'armv7'], \
    'Windows Server 2012':['64-bit'], 'Windows Home Server 2011':['64-bit'], 'Windows Server 2008 R2':['64-bit', 'Itanium-64'], \
    'Windows 7':['32-bit', '64-bit'], 'Windows Server 2008':['64-bit', 'Itanium-64', '32-bit'], 'Windows Vista':['32-bit', '64-bit'], \
    'Windows Server 2003 R2':['64-bit', '32-bit'],  'Windows Server 2003 R2':['64-bit', 'Itanium-64', '32-bit'], 'Windows XP':['64-bit', 'Itanium-64', '32-bit'], \
    'Windows 2000':['32-bit'], 'Windows NT 4.0':['32-bit'], 'Windows NT 3.51':['32-bit'], 'Windows NT 3.5':['32-bit'], 'Windows NT 3.1':['32-bit']}


# TODO: mantain updated this archive searching for known exploits in sources different from exploitdb and metasploit
CUSTOM_EXPLOITS_DICT = {
    'CVE-2016-7255': ['https://github.com/tinysec/public/tree/master/CVE-2016-7255'],
    'CVE-2016-7201': ['https://github.com/theori-io/chakra-2016-11'],
    'CVE-2016-7200': ['https://github.com/theori-io/chakra-2016-11'],
    'CVE-2016-3225': ['https://github.com/foxglovesec/RottenPotato', 'https://github.com/Kevin-Robertson/Tater', \
    'https://bugs.chromium.org/p/project-zero/issues/detail?id=222', 'https://foxglovesecurity.com/2016/01/16/hot-potato/'],
    'CVE-2015-1730': ['http://blog.skylined.nl/20161206001.html'],
    'CVE-2015-6131': ['https://code.google.com/p/google-security-research/issues/detail?id=514'],
    'CVE-2015-1701': ['https://github.com/hfiref0x/CVE-2015-1701'],
    'CVE-2015-0097': ['https://github.com/offensive-security/exploit-database-bin-sploits/raw/master/sploits/37657.zip'],
    'CVE-2016-3309': ['https://siberas.de/blog/2017/10/05/exploitation_case_study_wild_pool_overflow_CVE-2016-3309_reloaded.html', \
    'https://github.com/siberas/CVE-2016-3309_Reloaded'],
    'CVE-2017-0213': ['https://github.com/WindowsExploits/Exploits/tree/master/CVE-2017-0213'],
    'CVE-2012-0217': ['https://github.com/WindowsExploits/Exploits/raw/master/CVE-2012-0217/Binaries/sysret.exe', \
    'https://github.com/offensive-security/exploitdb-bin-sploits/raw/master/bin-sploits/20861.rar'],
    'CVE-2016-3309': ['https://github.com/WindowsExploits/Exploits/raw/master/CVE-2016-3309/Binaries/bfill.exe'],
    'CVE-2016-3371': ['https://github.com/WindowsExploits/Exploits/raw/master/CVE-2016-3371/Binaries/40429.exe'],
    'CVE-2016-7255': ['https://raw.githubusercontent.com/WindowsExploits/Exploits/master/CVE-2016-7255/CVE-2016-7255.ps1'],
    'CVE-2019-0708': ['https://github.com/zerosum0x0/CVE-2019-0708'],
}


# List of script's indexes for which none CVE was found also on the ExploitDB official website 
# They have been blacklisted in order to avoid ineffective queries to ExploitDB website when "--build" option is choosed 
BLACKLISTED_INDEXES = [
    '31046', '40715', '7826', '15001', '12640', '26196', '43518', '17313', '35318', '25607', '22758', '9492', '8969', \
    '4699', '11255', '25883', '36920', '18354', '19401', '34002', '33454', '38325', '11179', '20318', '8173', '12404', '22795', '9618', '39820', \
    '14428', '44565', '16999', '22959', '18933', '40523', '23511', '26409', '42704', '14497', '14857', '8273', '38457', '43472', '8193', '45402', \
    '29547', '7702', '46008', '11953', '9065', '38382', '5230', '19776', '1197', '31113', '10345', '46334', '8392', '17854', '38504', '16651', \
    '22515', '45151', '16778', '11400', '23093', '37808', '40778', '8301', '17721', '34821', '14158', '31423', '40426', '24354', '46370', '23451', \
    '45406', '12677', '7671', '24910', '44382', '20590', '9619', '7056', '42174', '37542', '11059', '16727', '17715', '16566', '15539', '42267', \
    '25835', '39260', '38185', '8368', '18693', '25695', '16459', '22448', '26403', '17268', '16664', '42630', '16723', '19145', '9650', '8742', \
    '22892', '14664', '9303', '19625', '42567', '10240', '37655', '20825', '16085', '1262', '18027', '16942', '8235', '20915', '42565', '22909', \
    '9354', '19932', '17302', '14077', '24262', '18603', '11205', '11220', '11328', '8930', '7692', '12331', '17104', '11750', '8233', '23152', \
    '9581', '18697', '8426', '40340', '14676', '42951', '35188', '22144', '14013', '30045', '40471', '46636', '38456', '24996', '18605', '19339', \
    '38904', '11384', '18826', '30244', '45496', '937', '25181', '9704', '42116', '22432', '13806', '22723', '25050', '9221', '8162', '36982', \
    '7264', '5462', '23996', '19877', '46660', '4188', '40831', '9229', '8938', '34831', '8371', '26956', '18681', '20393', '46668', '14215', \
    '11742', '19973', '28968', '17877', '11109', '17498', '41144', '18695', '19224', '40539', '3158', '12834', '14856', '25129', '29799', '42325', \
    '23365', '14496', '31624', '14762', '46346', '39105', '23643', '42154', '43236', '42310', '44281', '42538', '883', '25026', '41073', '21318', \
    '40868', '31359', '36984', '11663', '20120', '27611', '20265', '30336', '9299', '14355', '38513', '1626', '33971', '10320', '39954', '7935', \
    '23135', '40533', '22217', '42165', '37890', '40268', '40418', '8275', '44896', '14553', '44549', '15134', '17527', '42312', '11500', '23464', \
    '38704', '42163', '15450', '16639', '34967', '7745', '25166', '19622', '10331', '23211', '42155', '43104', '16976', '22465', '40681', '42128', \
    '20903', '34997', '17902', '9190', '41079', '34050', '25487', '4027', '40410', '28849', '40323', '18833', '46437', '16426', '14029', '34768', \
    '39594', '10556', '1978', '14779', '45280', '15542', '29897', '40582', '22193', '40903', '9291', '24505', '20112', '24366', '37799', '15762', \
    '38219', '31221', '17381', '8242', '11475', '16720', '45828', '1279', '12202', '8657', '20306', '37535', '27523', '10563', '22946', '15540', \
    '38244', '45738', '8227', '868', '23417', '81', '16739', '7827', '9831', '16647', '43132', '42057', '33829', '39845', '22932', '42159', '15357', \
    '16075', '1089', '38602', '24207', '40457', '25057', '22807', '22769', '21096', '2047', '8354', '23373', '41031', '11828', '36477', '23903', \
    '18760', '45354', '23123', '31474', '35928', '15861', '11257', '8338', '40400', '40714', '32152', '33431', '37731', '13907', '12815', '23222', \
    '42022', '25296', '19323', '11647', '40581', '18986', '14068', '28183', '42304', '16070', '19239', '20543', '16024', '24479', '30819', '37985', \
    '18683', '23034', '21842', '32752', '12501', '11372', '22113', '19586', '40541', '12516', '45778', '46331', '46335', '34870', '10373', '38700', \
    '35166', '46009', '16072', '24568', '37699', '33750', '15729', '33433', '37197', '7347', '20407', '38381', '23157', '11765', '20036', '9142', \
    '26299', '23184', '33453', '10542', '46189', '33035', '25086', '8419', '40071', '25095', '34174', '41310', '23461', '25204', '20022', '11468', \
    '28360', '40393', '9458', '11877', '22678', '34685', '33848', '23679', '40375', '24409', '22870', '16107', '9500', '40672', '18968', '46673', \
    '9466', '14382', '42568', '10475', '18967', '22528', '20575', '14752', '16439', '22185', '24304', '10664', '8589', '40670', '10911', '36115', \
    '19113', '34966', '17780', '7583', '42268', '41887', '24012', '11173', '40693', '19525', '10596', '17217', '14447', '9177', '42720', '40132', \
    '42521', '10371', '42550', '22966', '35881', '18032', '8234', '46222', '33705', '11694', '34830', '7706', '23037', '35560', '20571', '39661', \
    '8284', '34848', '16536', '42559', '40442', '14673', '40583', '35007', '22967', '9805', '42886', '20320', '12250', '33050', '46441', '36207', \
    '34648', '32050', '8970', '1277', '26494', '39510', '804', '35563', '15156', '35225', '42612', '15133', '22466', '41775', '14416', '33790', \
    '43338', '24219', '22827', '935', '42557', '37729', '37813', '45346', '12663', '43799', '36174', '40520', '11857', '16726', '46665', '20296', \
    '8299', '23847', '44713', '11656', '22734', '32456', '9638', '40017', '46120', '31769', '17692', '17460', '36075', '33890', '9902', '17434', \
    '34695', '36476', '46188', '35399', '34823', '10323', '26367', '39523', '24249', '40226', '35410', '39599', '40988', '39508', '23144', '16804', \
    '23552', '42691', '35714', '39808', '18947', '17985', '26957', '12024', '46016', '29234', '17543', '15081', '40482', '2283', '4234', '14756', \
    '38526', '35051', '39443', '14153', '17578', '24502', '7913', '40538', '14044', '25013', '42722', '13998', '24534', '42549', '19197', '9580', \
    '10920', '16636', '35468', '1099', '40473', '15071', '25652', '18397', '35671', '27526', '40528', '31040', '45079', '22526', '35885', '36501', \
    '31407', '24116', '19033', '40376', '4049', '20053', '24753', '35886', '40443', '23717', '14081', '7739', '1118', '22738', '20702', '8733', \
    '7918', '1178', '23040', '42694', '35741', '35948', '12673', '8666', '4061', '9687', '22635', '25419', '36587', '34047', '9983', '24712', \
    '46639', '11256', '10577', '14385', '17499', '46670', '8248', '37165', '33935', '9894', '17960', '21662', '31895', '17886', '20912', '7688', \
    '12498', '42087', '26230', '19412', '24258', '5536', '34527', '44658', '30802', '12821', '14551', '10054', '16499', '31260', '41771', '39662', \
    '2657', '11202', '11909', '22504', '14451', '14248', '24884', '36189', '27943', '16658', '12332', '17364', '8582', '46301', '42539', '36822', \
    '24572', '29213', '8554', '46269', '15782', '18013', '17489', '21142', '34836', '7684', '44903', '35119', '7923', '17229', '18929', '45675', \
    '37771', '45805', '9096', '39585', '19581', '39121', '42153', '40577', '6548', '9900', '17196', '14427', '23091', '16073', '930', '753', '38903', \
    '9816', '28376', '38330', '39786', '22951', '8421', '22691', '10797', '14605', '17604', '16169', '18096', '8340', '12582', '23493', '11661', \
    '11453', '31766', '21845', '9136', '41090', '24557', '17383', '33712', '35189', '1681', '36188', '34853', '40834', '39102', '27554', '40832', \
    '14633', '8158', '15885', '33941', '40438', '15541', '14753', '19589', '22869', '40484', '19291', '43936', '26242', '3274', '31788', '944', \
    '14492', '39009', '8651', '44174', '17354', '15417', '11779', '15706', '23503', '18038', '34371', '21757', '38227', '1180', '37951', '3176', \
    '4948', '20542', '22944', '9148', '9305', '14200', '25713', '38631', '46025', '41959', '18703', '29952', '23038', '22375', '45921', '32442', \
    '16560', '25841', '14257', '44364', '42551', '32737', '16644', '35590', '23678', '14576', '759', '36235', '24535', '25163', '16673', '46107', \
    '16078', '40178', '34230', '20643', '31699', '9882', '7765', '42705', '12680', '34542', '11152', '8541', '43879', '11539', '21705', '22022', \
    '10628', '9343', '38644', '17158', '18367', '14491', '560', '40234', '43339', '9680', '37320', '17893', '26221', '7655', '16705', '16544', \
    '42586', '10748', '26493', '30069', '23209', '27041', '9509', '20317', '44337', '10428', '17581', '40018', '11229', '24875', '11219', '14399', \
    '28724', '37716', '22213', '22785', '32778', '40148', '42778', '40540', '37211', '9234', '9540', '26491', '21843', '12035', '16633', '10642', \
    '22112', '23555', '7661', '23532', '40297', '42059', '25033', '11794', '8177', '14150', '40630', '31460', '14258', '8171', '20028', '28853', \
    '29035', '42186', '40072', '22562', '8754', '25144', '12621', '14586', '32457', '14600', '42077', '26411', '22142', '41538', '38533', '12310', \
    '9375', '24196', '17821', '8525', '23185', '18476', '28335', '15144', '42725', '1131', '24500', '11314', '39120', '42395', '14532', '1988', \
    '8208', '34844', '42328', '38486', '22434', '42157', '18349', '41207', '45085', '27606', '44423', '2689', '34832', '23411', '19968', '16009', \
    '29309', '39579', '35074', '7871', '17361', '90', '17365', '15368', '31930', '16807', '41309', '44389', '9286', '22218', '38871', '14878', \
    '9379', '558', '24863', '12051', '46561', '16242', '20426', '9851', '33611', '11791', '40452', '37344', '28969', '18611', '14612', '25146', \
    '41146', '22677', '22341', '41638', '34156', '43465', '33900', '20257', '9803', '11293', '16417', '35812', '22476', '8401', '38668', '24117', \
    '41772', '33964', '34686', '35809', '11682', '12581', '8117', '3675', '38860', '1260', '21631', '18557', '42558', '9149', '35226', '32460', \
    '17086', '33540', '14115', '42548', '40362', '25597', '46596', '30669', '42540', '36980', '42142', '21618', '21547', '35171', '38388', '42222', \
    '23649', '46098', '21803', '8142', '23044', '4177', '11191', '4751', '34512', '37737', '36258', '24584', '19506', '10787', '16132', '18478', \
    '34868', '32957', '17557', '127', '12203', '42455', '8422', '24767', '35509', '315', '15438', '44518', '12379', '33610', '11210', '28877', '43202', \
    '42723', '41917', '39968', '22563', '35897', '45289', '15445', '16771', '20876', '17605', '40422', '28170', '17388', '11900', '41929', '46530', \
    '22506', '40833', '38601', '39804', '20124', '41666', '28298', '1999', '17700', '4236', '24728', '8280', '26448', '14769', '37952', '14552', \
    '24571', '17441', '10759', '40835', '15480', '11797', '16471', '17306', '40461', '12511', '35529', '11315', '23450', '11151', '24944', '11093', \
    '22329', '19580', '45142', '50', '35612', '39008', '22136', '40984', '919', '17063', '960', '21320', '11420', '33841', '8160', '40902', '14658', \
    '27747', '25187', '25694', '17064', '46028', '12512', '25696', '16534', '34978', '40854', '25836', '35322', '42696', '43366', '34654', '44342', \
    '24220', '40497', '9895', '36111', '35446', '7994', '28681', '10359', '26523', '9886', '31988', '17053', '17459', '28955', '10007', '38220', \
    '14599', '13767', '17429', '14321', '15347', '15022', '32555', '42536', '32493', '34931', '4574', '16642', '3881', '22288', '1607', '24200', \
    '16704', '1986', '9813', '40417', '31972', '17754', '21887', '12803', '9984', '17362', '42261', '8765', '8560', '12750', '34331', '12261', '22652', \
    '36319', '19637', '11232', '7755', '21130', '14412', '14739', '16253', '23226', '46005', '24021', '10765', '36819', '37212', '8716', '730', \
    '10392', '9224', '16628', '40173', '7749', '34489', '42161', '21675', '11820', '10339', '16176', '42432', '23210', '11272', '14651', '7794', \
    '40567', '23121', '11944', '14934', '6880', '8159', '16737', '22674', '12189', '6407', '14482', '29032', '2403', '40040', '9660', '41349', '25784', \
    '22838', '26222', '24720', '27805', '41311', '31909', '40485', '22851', '27607', '21057', '15349', '21913', '22721', '17359', '33901', '14663', \
    '11413', '25023', '41320', '17277', '14098', '44365', '17417', '21994', '17275', '8535', '34115', '16054', '8564', '42984', '10335', '23041', \
    '21331', '40483', '30009', '21838', '8250', '21139', '8732', '18704', '44390', '29548', '36062', '18533', '36053', '23019', '11981', '18982', '45086', \
    '7988', '38762', '23910', '12247', '7926', '9676', '8311', '8789', '17519', '9216', '40322', '31583', '10374', '40455', '44187', '32826', '35921', \
    '45120', '232', '11333', '16793', '11573', '25025', '7656', '32699', '41265', '12248', '26044', '17540', '12312', '2091', '14630', '40494', '39985', \
    '33981', '16728', '16412', '38349', '7804', '15031', '36542', '40535', '22161', '8175', '36424', '3071', '15499', '9346', '34822', '25141', '15761', \
    '9409', '17294', '22779', '26306', '18656', '15235', '12367', '35001', '36837', '22835', '36981', '4050', '34869', '15033', '44363', '5445', '20214', \
    '25961', '8246', '39907', '40917', '15437', '10079', '769', '38694', '17450', '19293', '15336', '19857', '8178', '24919', '38319', '22676', '24961', \
    '29083', '38394', '46091', '21392', '23283', '17152', '37059', '1086', '45137', '42921', '44155', '42456', '8463', '4247', '16550', '36100', '15584', \
    '40587', '17619', '42683', '16978', '28876', '38452', '43421', '24890', '40459', '21090', '22972', '8200', '20758', '19143', '8174', '44267', '43156', \
    '9128', '7843', '24686', '44217', '34943', '25571', '44649', '2408', '1201', '43145', '23318', '40460', '12380', '34532', '17548', '16668', '11204', \
    '23225', '38600', '41148', '44218', '7853', '21883', '760', '22546', '2530', '16991', '8274', '41961', '15333', '20501', '15764', '8897', '19931', '297', \
    '23007', '22879', '18077', '19266', '27704', '23492', '23229', '15373', '46507', '38287', '172', '18915', '20262', '36049', '40425', '40579', '19617', \
    '29277', '7662', '44244', '32799', '7929', '18869', '1776', '44330', '40138', '35850', '33852', '36915', '12540', '2070', '37396', '17001', '19491', \
    '18401', '26032', '35880', '11139', '17328', '40522', '13756', '26035', '6705', '17360', '35652', '24213', '7762', '25554', '35130', '43209', '8149', \
    '12119', '30939', '22511', '8398', '17456', '21605', '36291', '14092', '16663', '20288', '16679', '22301', '2076', '17561', '34178', '15427', '42928', \
    '14309', '1108', '11161', '14275', '12580', '15868', '22488', '33207', '41003', '44582', '14503', '15941', '11208', '21910', '23083', '24943', '7957', \
    '32923', '22722', '20109', '18375', '10786', '40389', '18016', '17588', '8916', '8138', '932', '40427', '39755', '1958', '1085', '11267', '10346', '23321', \
    '34437', '23387', '16662', '1915', '16153', '23092', '7848', '24808', '45905', '3649', '36327', '29603', '17438', '802', '26579', '39122', '17225', '16957', \
    '20319', '44830', '16486', '5584', '14623', '16635', '26404', '40151', '25646', '38609', '35039', '35177', '20944', '34697', '9643', '9426', '12342', \
    '42160', '23340', '17373', '23002', '12403', '1664', '18866', '24374', '16716', '39674', '17150', '24802', '8189', '19937', '25022', '23052', '14681', \
    '34829', '8561', '34835', '14580', '40478', '16133', '37611', '42011', '19176', '24653', '35002', '40525', '12308', '12417', '25157', '9146', '40586', \
    '44455', '24958', '7748', '23871', '12388', '23544', '9970', '5625', '24187', '42767', '23243', '46283', '16173', '17416', '18500', '45660', '22564', \
    '44834', '22078', '19494', '9366', '42560', '17105', '42083', '16145', '17223', '8444', '16591', '44573', '19177', '40995', '9215', '9661', '32129', \
    '46255', '14464', '45744', '8179', '52', '45988', '26402', '34462', '7584', '46578', '9186', '23491', '40550', '38005', '22931', '39814', '15532', \
    '25034', '16138', '41672', '10376', '23489', '1128', '29292', '15763', '847', '5087', '15358', '1536', '44269', '3880', '14046', '8154', '10620', \
    '22354', '40758', '16446', '836', '22604', '17382', '7757', '40020', '313', '37020', '7966', '24174', '24496', '18657', '11215', '30783', '11317', \
    '40848', '42718', '9318', '25194', '17270', '18535', '24727', '24363', '15862', '18376', '22728', '10936', '25572', '1115', '40477', '46625', '18109', \
    '10047', '18981', '16141', '24014', '22556', '40350', '15866', '10010', '7334', '12044', '21394', '42256', '40830', '10039', '35813', '36250', '12480', \
    '811', '7747', '33980', '14191', '16736', '14400', '11872', '19442', '18640', '25188', '38923', '22782', '35744', '14402', '5461', '2821', '40741', \
    '8214', '24407', '20371', '8339', '46267', '46040', '24118', '33025', '42181', '3897', '38829', '25755', '4424', '45171', '40869', '9476', '34838', \
    '36417', '37964', '38384', '9298', '9885', '36533', '25573', '40145', '12213', '7989', '22636', '30883', '46021', '23419', '4325', '21713', '933', \
    '42918', '36861', '39980', '32491', '9272', '42311', '45071', '33426', '1420', '40585', '40767', '41321', '35190', '572', '17149', '44243', '17820', \
    '43033', '4487', '18748', '15855', '16092', '33974', '39916', '18062', '24901', '6813', '16711', '19613', '20409', '14885', '16977', '11764', '10098', \
    '1465', '32585', '9644', '40428', '24885', '9896', '10973', '8518', '18969', '35924', '8363', '42023', '11834', '40172', '10365', '40760', '23921', \
    '16177', '16971', '25167', '24413', '40580', '19623', '45101', '976', '16725', '27754', '18718', '17022', '9567', '14431', '12255', '46090', '44341', \
    '22094', '18624', '39783', '18448', '32049', '24687', '21214', '37730', '8863', '32426', '42721', '17977', '12679', '38218', '17230', '44224', '16734', \
    '11046', '17607', '33172', '7707', '19671', '16721', '6175', '693', '23068', '14527', '10056', '2671', '29814', '23886', '23768', '14728', '18634', \
    '18534', '36928', '11847', '11879', '26134', '19942', '18067', '28884', '34696', '23198', '7763', '36056', '11331', '40458', '2079', '20545', '34013', \
    '38243', '17492', '43179', '40445', '22219', '40335', '8537', '22854', '40456', '33432', '36909', '45710', '6100', '45504', '44680', '44841', '39729', \
    '44787', '44838', '45350', '45325', '45356', '46018', '4754', '16738', '5330', '44840', '45250', '8799', '45259', '45467', '16743', '45349', '46056', \
    '44499', '45796', '45235', '14941', '46058', '45352', '15102', '45355', '45181', '45531', '45627', '3451', '45492', '11112', '45888', '41705', '45598', \
    '45442', '14961', '46059', '11408', '43192', '45353', '40348', '40342', '45166', '39984', '41020', '40337', '45176', '41605', '39520', '45159', '40349', \
    '39999', '44784', '40336', '40380', '42435', '40451', '45165', '45378', '45194', '45395'
]



# TODO: mantain updated this archive searching for official MS Advisories
# Known MS Advisory to be added in CVE research
# Advisories for RCE ADV190005-->CVE-2019-0595
# Advisories for PRIV ESCAL ADV990001-->CVE-2018-8566
KNOWN_ADV_TOTAL = {'ADV190005':['CVE-2019-0595'], 'ADV990001':['CVE-2018-8566']}
# Known MS Advisories without CVE or with CVEs but not interesting vulns
KNOWN_ADV_PURGED = ['ADV190009', 'ADV180005', 'ADV170012', 'ADV180013']





def argument_parser():
    """
    Command line arguments parser
    """
    input_parser = argparse.ArgumentParser(description='Windows Exploit Dowser')
    input_parser.add_argument("-d", "--database", help="feed in with your local MS Bulletin database file")
    input_parser.add_argument("-u", "--update", help="update the MS Bulletin database", action="store_true")    
    input_parser.add_argument("-e", "--exploitdb_dir", help="feed in with your local ExploitDB folder [Default "+DEFAULT_EXPLOIDB_DIR+"]")
    input_parser.add_argument("-m", "--meta_dir", help="feed in with your local Metasploit folder [Default "+DEFAULT_META_DIR+"]") 
    input_parser.add_argument("-v", "--verbose", help="select it for a verbose output", action="store_true")
    input_parser.add_argument("-c", "--crash", help="consider also for DoS exploits [By default they are discarded]", action="store_true")
    input_parser.add_argument("-g", "--greedy", help="consider also exploits for MS software components [Increase false positives]", action="store_true")
    input_parser.add_argument("-t", "--target", help="insert here the string with target OS characteristics (between double quotes) [i.e. \"Windows XP SP3 64 bits\"]")

    # Additional option needed because some ExploitDB scripts have not CVE embedded on source code but only extractable parsing the pages of the official ExploitDB website
    input_parser.add_argument("-b", "--build", help="build/update the csv file with missing exploits parsed from official ExploitDB website [Decrease false negatives], feed in with your local ExploitDB folder [Default "+DEFAULT_EXPLOIDB_DIR+"]")

    # The systeminfo and wmic input file are mutually exclusive
    inputinfo_type = input_parser.add_mutually_exclusive_group()
    inputinfo_type.add_argument("-s", "--systeminfo", help="feed in an input file that contains the \"systeminfo\" command")
    inputinfo_type.add_argument("-w", "--wmicinfo", help="feed in an input file that contains the \"wmic qfe list full\" command")

    # It is possible to define the kind of exploit to search
    exploit_type = input_parser.add_mutually_exclusive_group()
    exploit_type.add_argument("-r", "--remote", help="search remote exploits only [Remote Code Execution]", action="store_true")
    exploit_type.add_argument("-l", "--local", help="search local exploits only [Privilege Escalation]", action="store_true")
    
    args = input_parser.parse_args()

    if len(sys.argv) <= 1:
        input_parser.print_usage()
        exit(1)

    return args





def get_bulletin():
    """
    Download MS Bulletin file from the new official Microsoft Reference
    """  
    # Set values and headers for the MS Bulletin download request
    values = {
        'familyIds':[100000000,100000001,100000002,100000003,100000004,100000005,100000006,100000007,5000,100000008,100000009,100000010], 
        'productIds': [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,\
        52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,\
        104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,\
        145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,\
        186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,\
        227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,\
        268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,\
        309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,\
        350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,\
        391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,\
        432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,\
        473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,\
        514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,\
        555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,\
        596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,\
        637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,\
        678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,\
        719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761], 
        'severityIds':[1,2,3,4,5], 'impactIds':[1,2,4,9], 'pageNumber':1, 'pageSize':20, 'includeCveNumber':True, 'includeSeverity':True, 'includeImpact':True, 
        'orderBy':'publishedDate', 'orderByMonthly':'releaseDate', 'isDescending':True, 'isDescendingMonthly':True, 'queryText':'', 'isSearch':False, 
        'filterText':'', 'fromPublishedDate':''+ NEW_BULLETIN_START_DATE +'', 'toPublishedDate':''+ TODAY +''
        }
    
    headers = {
        'Host':'portal.msrc.microsoft.com',
        'User-Agent':'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:65.0) Gecko/20100101 Firefox/65.0',
        'Referer':'https://portal.msrc.microsoft.com/en-us/security-guidance',
        'Content-Type':'application/json;charset=utf-8',
        'Accept':'application/json, text/plain, */*',
        'Accept-Language':'en-US,en;q=0.5',
        'Accept-Encoding':'gzip, deflate',
        'Connection':'close',
    }

    # Build the HTTP POST request and try to download an updated MS Bulletin
    msb_req = urllib.request.Request(MSBULLETIN_URL, data=json.dumps(values).encode('utf8'), headers=headers)
    print("[*] Starting download of MS Bulletin from: \"%s\"..." % MSBULLETIN_URL)

    try:
        msb_resp = urllib.request.urlopen(msb_req)
    except urllib.request.HTTPError as e:
        print("[-] ERROR: Exception while requesting the url: %s, response code: %d\n %s" % (MSBULLETIN_URL, e.code, traceback.format_exc()))
        return False       
    except urllib.request.URLError as e:
        print("[-] ERROR: Exception while trying to connect with: %s\n %s" % (MSBULLETIN_URL, e.args))
        return False
    # Read and save the bulletin file as xlsx
    downloaded_bulletin = msb_resp.read()
    print("[*] Saving downloaded MS Bulletin as: \"%s\"" % MSBULLETIN_FILE)
    with open(MSBULLETIN_FILE, 'wb') as file:
        file.write(downloaded_bulletin)
    return True






def get_old_bulletin():
    """
    Download MS Bulletin file from the old official Microsoft Reference
    """
    headers = {
        'User-Agent':'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:65.0) Gecko/20100101 Firefox/65.0',
        'Connection':'close',
    }
    # Build the HTTP POST request and try to download an updated MS Bulletin
    old_msb_req = urllib.request.Request(OLD_MSBULLETIN_URL, None, headers=headers)
    print("[*] Starting download of old MS Bulletin from: \"%s\"..." % OLD_MSBULLETIN_URL)

    try:
        old_msb_resp = urllib.request.urlopen(old_msb_req)
    except urllib.request.HTTPError as e:
        print("[-] ERROR: Exception while requesting the url: %s, response code: %d\n %s" % (OLD_MSBULLETIN_URL, e.code, traceback.format_exc()))
        return False
    except urllib.request.URLError as e:
        print("[-] ERROR: Exception while trying to connect with: %s\n %s" % (OLD_MSBULLETIN_URL, e.args))
        return False
    # Read and save the bulletin file as xlsx
    downloaded_old_bulletin = old_msb_resp.read()
    print("[*] Saving downloaded old MS Bulletin as: \"%s\"" % OLD_MSBULLETIN_FILE)
    with open(OLD_MSBULLETIN_FILE, 'wb') as file:
        file.write(downloaded_old_bulletin)
    return True






def find_exploits(folder, is_meta, no_dos):
    """
    Retrieve exploits from ExploitDB and Metasploit local folders
    """
    exp_dict = {}
    fnames = []
    valid_fnames = []
    # This list remain empty when is_meta value is True
    hidden_cve_files = []

    # Start here ExploitDB section
    if not is_meta:
        for root,subdir,files in os.walk(folder):
            for filename in files:
                if no_dos:
                    # Discard DoS ExploitDB files
                    if not root.endswith("dos"):
                        fnames.append(os.path.join(root, filename))
                else:
                    # Also dos exploits are accepted
                    fnames.append(os.path.join(root, filename))
        fnames = list(set(fnames))
        # Then search CVEs for each file
        for fname in fnames:
            matches = []
            has_cve = False
            fh = open(fname,'r')
            for line in fh:
                match = re.search('CVE', line)
                if match:
                    matches.append(match.string)
                    has_cve = True
            fh.close()
            if has_cve:
                # Create a dict with CVEs and file-paths
                for m in matches:
                    m_cve = re.findall('[\d]{4}-[\d]{4,5}', m)
                    if m_cve:
                        # A list of one CVE item is expected
                        if len(m_cve) == 1:
                            exp_dict['CVE-' + str(m_cve[0])] = [fname]
            else:
                hidden_cve_files.append(fname)
    # End of ExploitDB section
    # Start here Metasploit section
    else:
        for root,subdir,files in os.walk(folder):
            for filename in files:
                fnames.append(os.path.join(root, filename))
        if no_dos:
            # Discard DoS metasploit files
            for fname in fnames:
                fh = open(fname,'r')
                for line in fh:
                    match_dos = re.search('denial| dos', line.lower())
                    if not match_dos:
                        valid_fnames.append(fname)
                fh.close()
        else:
            # Also dos exploits are accepted
            valid_fnames = fnames
        valid_fnames = list(set(valid_fnames))
        # Then search CVEs for each file
        for valid_fname in valid_fnames:
            matches = []
            vfh = open(valid_fname,'r')
            for vline in vfh: 
                match = re.search('CVE', vline)
                if match:
                    matches.append(match.string)
            vfh.close()
            # Create a dict with CVEs and file-paths
            for m in matches:
                m_cve = re.findall('[\d]{4}-[\d]{4,5}', m)
                if m_cve:
                    # A list of one CVE item is expected
                    if len(m_cve) == 1:
                        exp_dict['CVE-'+str(m_cve[0])] = [valid_fname]
    # End of Metasploit section
    return exp_dict, hidden_cve_files





def update_exploits(exploitdb_dir, meta_dir, no_dos):
    """
    Update the list of exploits from Exploitdb and Metasploit local repos
    """
    exploit_dict = {}
    edb_dict = {}
    meta_dict = {}
    tmp_dict = {}

    if not exploitdb_dir:
        exploitdb_dir = DEFAULT_EXPLOIDB_DIR
    if not meta_dir:
        meta_dir = DEFAULT_META_DIR

    # Update exploitdb list
    if not os.path.isdir(exploitdb_dir):
        print("[!] WARNING: The ExploitDB local repo was not found")
    else:
        print("[*] Searching new exploits in the ExploitDB local folder \"%s\"" % exploitdb_dir)
        win_dirs = ['/windows/', '/windows_x86/', '/windows_x86-64/']
        if [x for x in win_dirs if x not in exploitdb_dir]:
            # Go here if user have not specified an ExploitDB sub-folder as exploitdb_dir (none of: '/windows/', '/windows_x86/', '/windows_x86-64/') 
            if os.path.isdir(exploitdb_dir):
                for win_dir in win_dirs:
                    win_dict,_ = find_exploits(exploitdb_dir.rstrip('/') + win_dir, False, no_dos)
                    for win_k,win_v in iteritems(win_dict):
                        if win_k in edb_dict:
                            tmp_dict[win_k] = list(set(edb_dict[win_k] + win_v))
                        else:
                            tmp_dict[win_k] = win_v
                    edb_dict = tmp_dict  
        else:
            # Go here if user have specified an ExploitDB sub-folder as exploitdb_dir (any of: '/windows/', '/windows_x86/', '/windows_x86-64/') 
            if os.path.isdir(exploitdb_dir):
                win_dict,_ = find_exploits(exploitdb_dir, False, no_dos)
                for win_k,win_v in iteritems(win_dict):
                    if win_k in edb_dict:
                        tmp_dict[win_k] = list(set(edb_dict[win_k] + win_v))
                    else:
                        tmp_dict[win_k] = win_v
                edb_dict = tmp_dict             
    # Update metasploit list
    if os.path.isdir(meta_dir):
        print("[*] Searching new exploits in the Metasploit local folder \"%s\"" % meta_dir)
        meta_dict,_ = find_exploits(meta_dir, True, no_dos)
    else:
        print("[!] WARNING: The Metasploit local repo was not found")
    # Then update the final exploit dictionary
    if edb_dict and not meta_dict:
        exploit_dict = edb_dict
    if meta_dict and not edb_dict:
        exploit_dict = meta_dict
    if edb_dict and meta_dict:
        # Merge exploitdb and metasploit dictionaries
        exploit_dict = meta_dict
        for edb_k,edb_v in iteritems(edb_dict):
            if edb_k in exploit_dict:
                tmp_dict[edb_k] = list(set(exploit_dict[edb_k] + edb_v))
            else:
                tmp_dict[edb_k] = edb_v
        exploit_dict = tmp_dict
    return exploit_dict   





def build_hidden_exploitdb(exploitdb_dir, no_dos, use_blacklist):
    """
    Build/update a csv file with the ExploitDB scripts having CVEs retriveable only from official website
    """
    indexes = []
    headers = {'User-Agent':'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:65.0) Gecko/20100101 Firefox/65.0'}
    found_cves = []
    found_cve = ''
    hidden_values = []
    replaced_hidden_v = []
    hidden_cve_files = []
    local_hidden_dict = {}
    temp_dict = {}
    missing_hidden_cves_list = []
    blacklisted_indexes = []

    # By default some indexes have been blacklisted because their CVEs are not retriveable even on the official ExploitDB site
    if use_blacklist:
        blacklisted_indexes = BLACKLISTED_INDEXES
    print("[+] Starting search for new exploits with hidden CVEs")
    if not exploitdb_dir:
        exploitdb_dir = DEFAULT_EXPLOIDB_DIR
        print("[!] WARNING: The local ExploitDB folder was not specified, considering default location.")
    # Check if the local exploitdb repo exists
    if not os.path.isdir(exploitdb_dir):
        print("[-] ERROR: Exiting, the ExploitDB local repo was not found")
        exit(1)
    # Search all the files without embedded CVEs in source code
    win_dirs = ['/windows/', '/windows_x86/', '/windows_x86-64/']
    if [x for x in win_dirs if x not in exploitdb_dir]:
        if os.path.isdir(exploitdb_dir):
            # Go here if user have not specified an ExploitDB sub-folder 
            # as exploitdb_dir (none of: '/windows/', '/windows_x86/', '/windows_x86-64/')
            for win_dir in win_dirs:
                if os.path.isdir(exploitdb_dir + win_dir):
                    _,hcve_files = find_exploits(exploitdb_dir.rstrip('/') + win_dir, None, no_dos)
                hidden_cve_files += hcve_files
    else:
        if os.path.isdir(exploitdb_dir):
            _,hidden_cve_files = find_exploits(exploitdb_dir, None, no_dos)

    # Check if the local database csv file exists
    if os.path.isfile(LOCAL_DB_CSV):
        fh = open(LOCAL_DB_CSV,'r')
        csv_rd = csv.reader(fh, delimiter=';')
        for row in csv_rd:
            # Populate the dictionary with CVEs as keys and the list of corresponding filepaths as values
            local_hidden_dict[row[0]] = row[1].split(', ')
        fh.close()
    else:
        print("[!] WARNING: The csv file \"%s\" was not found, so building it from scratch..." % LOCAL_DB_CSV)

    # Align hidden dict filepath values with the local ExploitDB repo filepath with 
    if local_hidden_dict:  
        for hidden_k,hidden_v in iteritems(local_hidden_dict):
            hidden_values += hidden_v
            # Check if the filepath in the local hidden database is equal to the real local ExploitDB repo
            m_hcf = re.search(r'(([\/\w]+)\/exploitdb\/exploits)', os.path.dirname(hidden_cve_files[0]))
            m_hv = re.search(r'(([\/\w]+)\/exploitdb\/exploits)', os.path.dirname(hidden_v[0]))
            if m_hcf.group(2) != m_hv.group(2):
                # Update filepath with the correct local ExploitDB repo folder
                print("[!] WARNING: Replacing the prepending paths \"%s\" in the local hidden CVE dictionary with the following correct path \"%s\"" % (m_hv.group(2), m_hcf.group(2)))
                for hv_elem in hidden_v:
                    hv_elem.replace(m_hv.group(2), m_hcf.group(2))
                    replaced_hidden_v.append(hv_elem)
                local_hidden_dict[hidden_k] = replaced_hidden_v

        for hidden_k,hidden_v in iteritems(local_hidden_dict):
            hidden_values += hidden_v
            temp_dict[hidden_k] = hidden_v

    # Check if there are new exploits with hidden CVEs
    missing_hidden_cves_list = [item for item in hidden_cve_files if item not in hidden_values]
    if not missing_hidden_cves_list:
        print("[+] Update not needed, local ExploitDB repo and local hidden CVE database are aligned")
        return

    # Download the hidden cve scripts from the ExploitDB official site
    # NOTE: this phase could be very slow
    print("[+] Starting search of hidden CVE on \"%d\" ExploitDB html pages (this phase could be very slow)..." % len(missing_hidden_cves_list))
    for hcve in missing_hidden_cves_list:
        # Extract filename from filepath and also discard file extension
        index,_ = os.path.splitext(os.path.split(hcve)[1])
        print("Downloading the \"%s\" script from ExploitDB website" % index)
        if not index in blacklisted_indexes:
            url_index = EXPLOITDB_URL + index
            req = urllib.request.Request(url_index, None, headers=headers)
            try:
                resp = urllib.request.urlopen(req)
            except urllib.request.HTTPError as e:
                print("[-] ERROR: Exception while requesting the url: %s, response code: %d\n %s" % (url_index, e.code, traceback.format_exc()))
                continue
            except urllib.request.URLError as e:
                print("[-] ERROR: Exception while trying to connect with: %s\n %s" % (url_index, e.args))
                continue
            # Parse the HTML pages containing the CVEs identifiers
            downloaded_html = resp.read()
            soup = BeautifulSoup(downloaded_html, 'html.parser')
            meta_tags = soup.findAll('meta', attrs={'name':'description'})
            cve_string = meta_tags[0]['content'].encode('utf-8')
            found_cves = re.findall(r'(CVE-[\d]{4}-[\d]{4,5})+', cve_string.decode('utf-8'))
            # Warning user for each page of ExploitDB official site where none CVE have been found
            if not found_cves:
                print("[!] WARNING: It is suggested a more in-depth search for the CVEs associated to the script \"%s\"" % url_index)
            for f_cve in found_cves:
                if f_cve in temp_dict:
                    temp_dict[f_cve] += [hcve]
                else:
                    temp_dict[f_cve] = [hcve]

    if local_hidden_dict != temp_dict:
        print("[+] Found %d new items to add in the csv file of exploits with hidden CVEs:\n %s" % (len(temp_dict), temp_dict))
    else:
        # The found missing exploits with hidden CVE are all in BLACKLISTED_INDEXES
        print("[+] Update not needed, local ExploitDB repo and local hidden CVE database are aligned")
        return 

    # Save the updated exploits in the local csv file
    local_hidden_dict = temp_dict
    fh = open(LOCAL_DB_CSV,'w')
    csv_wr = csv.writer(fh, quoting=csv.QUOTE_NONE, delimiter=';')#, escapechar='\\')
    for l_key,l_value in iteritems(local_hidden_dict):
        csv_wr.writerow([l_key, ', '.join(elem for elem in l_value)])
    fh.close()
    return





def update_local_dict(updates_dict):
    """
    Update the exploit local dictionary merging all the exploits
    """
    local_hidden_dict = {}
    temp_dict = {}
    # Merge hardcoded custom dict with hardcoded c written exploitdb dict
    local_dict = CUSTOM_EXPLOITS_DICT
    temp_dict = local_dict
    # Check if the hidden cve database csv file exists
    if os.path.isfile(LOCAL_DB_CSV):
        fh = open(LOCAL_DB_CSV,'r')
        csv_rd = csv.reader(fh, delimiter=';')
        for row in csv_rd:
            # Populate the dictionary with CVEs as keys and the list of corresponding filepaths as values
            local_hidden_dict[row[0]] = row[1].split(', ')
        fh.close()
    else:
        print("[!] WARNING: The csv file with hidden CVEs was not found (use \"--build\" option to generate it), sadly now you will obtain more false negatives...")
    if local_hidden_dict:
        for lhedb_k,lhedb_v in iteritems(local_hidden_dict):
            if lhedb_k in local_dict:
                temp_dict[lhedb_k] = list(set(local_dict[lhedb_k] + lhedb_v))
            else:
                temp_dict[lhedb_k] = lhedb_v
    # Then merge the local dict with updated exploit dict and hidden cve dict
    if not updates_dict:
        print("[-] None new exploit was updated, then using only default exploits")
    for u_key, u_value in iteritems(updates_dict):
        if u_key in local_dict:
            temp_dict[u_key] = list(set(local_dict[u_key] + u_value))
        else:
            temp_dict[u_key] = u_value
    local_dict = temp_dict
    return local_dict





def detect_encoding(filename):
    """
    Detect char encoding of input file
    https://stackoverflow.com/questions/3323770/character-detection-in-a-text-file-in-python-using-the-universal-encoding-detect
    """
    try:
        import chardet
        data = open(filename, "r").read()
        result = chardet.detect(data)
        encoding = result['encoding']
        return encoding
    except:
        return None




def print_str(osName, osRelease, osServicePack, osArch):
    """
    Provide a printable string for the target OS characteristics
    """
    printable = osName
    if osRelease:
        printable += ' Release ' + osRelease
    if osServicePack:
        printable += ' SP ' + osServicePack
    if osArch:
        printable += ' Arch ' + osArch
    return printable





def read_systeminfo(sysinfo):
    """
    Parse the submitted Systeminfo file printed from the target OS
    """
    osInfo = ''
    osName = ''
    osRelease = ''
    osServicePack = ''
    osArch = ''
    osPatches = []
    # First checks for existence of the file systeminfo
    if not os.path.isfile(sysinfo):
        print("[-] ERROR: Exiting, the specified systeminfo file %s does not exists." % sysinfo)
        exit(1)
    # Then try to detect the systeminfo file encoding
    encodings = ['iso-8859-2', 'utf-8', 'utf-16', 'utf-16-le', 'utf-16-be']
    detected_encoding =  detect_encoding(sysinfo)
    # And insert the detected encoding as head element
    if detected_encoding: 
        encodings.insert(0, detected_encoding)

    cmdfile = None
    cmdoutput = None
    is64 = False
    isItanium = False
    # Read the systeminfo file and extract cmdfile and cmdoutput
    for encoding in encodings:
        try:
            cmdfile = io.open(sysinfo, "r", encoding=encoding) # throws UnicodeDecodeError      
            cmdoutput = cmdfile.readlines() # throws UnicodeError
            break
        except (UnicodeError, UnicodeDecodeError) as e:
            # Failed to read file with the used encoding, trying with subsequent...
            continue
        # Some important error occurred
        except:
            print("[-] ERROR: could not read from input file specified: %s." % sysinfo)
            exit(1)  
    # Ended reading systeminfo file without results, something gone wrong
    if not cmdfile or not cmdoutput:
      print("[-] ERROR: could not read from input file, or could not detect encoding.")
      exit(1)
    
    # Parse systeminfo content searching OS version and installed patches
    for line in cmdoutput:
        # Search for the "Microsoft Windows" pattern which contains the OS infos
        if 'Microsoft' in line and 'Windows' in line and not osInfo:
            matchOS = re.search(r'(microsoft windows[^\n]+)', line.lower())
            if matchOS:
                osInfo = matchOS.group(0)
        # Search for the "KB" or "]: " patterns which contain the OS Patches infos
        if ('KB' in line) and (']: ' in line):
            matchPatch = re.search(r'((\d){5,10})', line.lower())
            if matchPatch:
                osPatches.append(matchPatch.group(0))

        # Search for the OS architecture which could be 32 bits, 64 bits or Itanium
        match64 = re.search(r'(64-based|x64| 64|i64|64bit|64 bit|64-bit)', line)
        matchItanium = re.search(r'(itanium)', line)
        if match64:
            is64 = True
        if matchItanium:
            isItanium = True

    # Check if the OS infos were correctly extracted from systeminfo file
    if not osInfo:
        print("[-] Exiting, unable to determine the Windows versions from the sysinfo file specified: %s." % sysinfo)
        exit(1)
    else:
        # Extract OS name, release, service pack, architecture and patch level
        match = re.search(r'(^microsoft windows[\s]*\b((home )?server |[\s]*)\b[^\s]+)', osInfo)
        if match:
            # NOTE: the new format of MS bulletins deleted "microsoft" pattern from product name
            osName = match.group(0).replace('microsoft ','') 
        match = re.search(r'( r| rc|release|rel)[\s]*(\d)', osInfo)
        if match:
            osRelease = match.group(2)
        match = re.search(r'(sp|pack|pack:)[\s]*(\d)', osInfo)
        if match:
            osServicePack = match.group(2)
        # Architecture could be 32 bits, 64 bits or Itanium
        if is64:
            osArch = '64'
        elif isItanium:
            osArch = 'itanium'
        # Check for implicit 64bit windows OS
        elif is_implicit64bit(osName, osRelease):
            # Force unidentified architecture to 64 bit for some known Windows versions
            osArch = '64'
        else:
            osArch = '32'

    printable_str = print_str(osName.title(), osRelease, osServicePack, osArch)
    print("[*] Starting exploit enumeration for target OS \"%s\"..." % printable_str)
    return osName,osRelease,osServicePack,osArch,osPatches





def parse_targetinput(user_input_string):
    """
    Extract the target OS infos from  the submitted user input
    """
    osInfo = ''
    osName = ''
    osRelease = ''
    osServicePack = ''
    osArch = ''

    # First extract infos on target OS from user input string
    osInfo = user_input_string.lower()
    match = re.search(r'(^(microsoft )?windows[\s]*\b((home )?server |[\s]*)\b[^\s]+)', osInfo)
    if match:
        # NOTE: the new format of MS bulletins deleted "microsoft" pattern from product name
        osName = match.group(0).replace('microsoft ','') 
    match = re.search(r'( r| rc|release|rel)[\s]*(\d)', osInfo)
    if match:
        osRelease = match.group(2)
    match = re.search(r'(sp|pack|pack:)[\s]*(\d)', osInfo)
    if match:
        osServicePack = match.group(2)
    # Architecture could be 32 bits, 64 bits or Itanium
    match64 = re.search(r'(64-based|x64| 64|i64|64bit|64 bit|64-bit)', osInfo)
    matchItanium = re.search(r'(itanium)', osInfo)
    if match64:
        osArch = '64'
    elif matchItanium:
        osArch = 'itanium'
    # Check for implicit 64bit windows OS
    elif is_implicit64bit(osName, osRelease):
        # Force unidentified architecture to 64 bit for some known OS versions
        osArch = '64'
    else:
        osArch = '32'

    return osName,osRelease,osServicePack,osArch





def read_wmicinfo(wmicinfo, user_input_string):
    """
    Parse the submitted Wmic file printed from the target OS
    """
    osPatches = []
    # Retrieve OS infos from user input
    osName, osRelease, osServicePack, osArch = parse_targetinput(user_input_string)
    # First checks for existence of the file wmicinfo
    if not os.path.isfile(wmicinfo):
        print("[-] ERROR: Exiting, the specified wmicinfo file %s does not exists." % wmicinfo)
        exit(1)
    # Then try to detect the systeminfo file encoding
    encodings = ['utf-8', 'utf-16', 'utf-16-le', 'utf-16-be', 'iso-8859-2']
    detected_encoding =  detect_encoding(wmicinfo)
    # And insert the detected encoding as head element
    if detected_encoding: 
        encodings.insert(0, detected_encoding)

    cmdfile = None
    cmdoutput = None
    # Read the systeminfo file and extract cmdfile and cmdoutput
    for encoding in encodings:
        try:
            cmdfile = io.open(wmicinfo, "r", encoding=encoding) # throws UnicodeDecodeError      
            cmdoutput = cmdfile.readlines() # throws UnicodeError
            break
        except (UnicodeError, UnicodeDecodeError) as e:
            # Failed to read file with the used encoding, trying with subsequent...
            continue
        # Some important error occurred
        except:
            print("[-] ERROR: could not read from input file specified: %s" % wmicinfo)
            exit(1)  
    # Ended reading systeminfo file without results, something gone wrong
    if not cmdfile or not cmdoutput:
      print("[-] ERROR: could not read from input file, or could not detect encoding")
      exit(1)

    # Parse wmicinfo content searching OS version and installed patches
    for line in cmdoutput:
        if ('KB' in line):
            matchPatch = re.search(r'((\d){5,10})', line.lower())
            if matchPatch:
                osPatches.append(matchPatch.group(0))

    printable_str = print_str(osName.title(), osRelease, osServicePack, osArch)
    print("[*] Starting exploit enumeration for target OS \"%s\"..." % printable_str)
    return osName,osRelease,osServicePack,osArch,osPatches





def read_bulletin(msdatabaseFile, osName, vulnType, isGreedy):
    """
    Parse downloaded MS Bulletin file searching only target OS infos
    """
    # First checks for  the existance of the MS Buletin file
    if not os.path.isfile(msdatabaseFile):
        print("[-] ERROR: Exiting, bulletin file %s is not present." % msdatabaseFile)
        exit(1)
    # Then copy the file into a csv temporary file
    workbook = xlrd.open_workbook(msdatabaseFile, on_demand=True)
    worksheet = workbook.sheet_by_index(0)

    product_col = 1
    CVE_col = 8
    patchID_col = 4
    impact_col = 7
    family_col = 2
    platform_col = 3
    bulletin_dict = {}    
    cve_list = []    
    known_adv_dict = KNOWN_ADV_TOTAL
    adv_list = []
    adv_bulletin_dict = {}
    unmatching_adv = []

    # Searching for Privilege Escalation only
    if vulnType == 'local':
        # Create a nested dict with CVE, product name and patch identifier values
        for r in range(0, worksheet.nrows):
            was_inserted = False
            # Only two kinds of exploits are considered
            if worksheet.cell(r, impact_col).value == 'Elevation of Privilege':
                matchFamily = re.search(r'(windows)', worksheet.cell(r, family_col).value.lower())
                matchPlatform = re.search(r'(windows)', worksheet.cell(r, platform_col).value.lower())
                if matchFamily:
                    if worksheet.cell(r, product_col).value.lower().startswith(osName):
                        cve_list.append(worksheet.cell(r, CVE_col).value)
                        bulletin_dict[str(worksheet.cell(r, patchID_col).value)] = {}
                        bulletin_dict[worksheet.cell(r, patchID_col).value.lower()][worksheet.cell(r, product_col).value.lower()] = list(set(cve_list))
                        was_inserted = True
                elif isGreedy and matchPlatform and not was_inserted:
                    # Searching also on MS components potentially installed on the detetcted OS name [many false positives]
                    if worksheet.cell(r, platform_col).value.lower().startswith(osName):
                        cve_list.append(worksheet.cell(r, CVE_col).value)
                        bulletin_dict[str(worksheet.cell(r, patchID_col).value)] = {}
                        bulletin_dict[worksheet.cell(r, patchID_col).value.lower()][worksheet.cell(r, product_col).value.lower()] = list(set(cve_list))

    # Searching for Remote Code Execution only
    elif vulnType == 'remote':
        # Create a nested dict with CVE, product name and patch identifier values
        for r in range(0, worksheet.nrows):
            was_inserted = False
            # Only for 2 kinds of exploits are considered
            if worksheet.cell(r, impact_col).value == 'Remote Code Execution':
                matchFamily = re.search(r'(windows)', worksheet.cell(r, family_col).value.lower())
                matchPlatform = re.search(r'(windows)', worksheet.cell(r, platform_col).value.lower())
                if matchFamily:
                    if worksheet.cell(r, product_col).value.lower().startswith(osName):
                        cve_list.append(worksheet.cell(r, CVE_col).value)
                        bulletin_dict[str(worksheet.cell(r, patchID_col).value)] = {}
                        bulletin_dict[worksheet.cell(r, patchID_col).value.lower()][worksheet.cell(r, product_col).value.lower()] = list(set(cve_list))
                        was_inserted = True
                elif isGreedy and matchPlatform and not was_inserted:
                    # Searching also on MS components potentially installed on the detetcted OS name [many false positives]
                    if worksheet.cell(r, platform_col).value.lower().startswith(osName):
                        cve_list.append(worksheet.cell(r, CVE_col).value)
                        bulletin_dict[str(worksheet.cell(r, patchID_col).value)] = {}
                        bulletin_dict[worksheet.cell(r, patchID_col).value.lower()][worksheet.cell(r, platform_col).value.lower()] = list(set(cve_list))

    # Searching for main misc vulnerabilities (RCE, PrivEsc, DefInDepth and SecByp)
    else:
        # Create a nested dict with CVE, product name and patch identifier values
        for r in range(0, worksheet.nrows):
            was_inserted = False
            #if worksheet.cell(r, impact_col).value in ['Remote Code Execution', 'Elevation of Privilege', 'Defense in Depth', 'Security Feature Bypass']:
            if worksheet.cell(r, impact_col).value == 'Remote Code Execution' or worksheet.cell(r, impact_col).value == 'Elevation of Privilege':
                matchFamily = re.search(r'(windows)', worksheet.cell(r, family_col).value.lower())
                matchPlatform = re.search(r'(windows)', worksheet.cell(r, platform_col).value.lower())
                cve_list = []
                if matchFamily:
                    # Identify the rows matching with OS name
                    if worksheet.cell(r, product_col).value.lower().startswith(osName):
                        cve_list.append(worksheet.cell(r, CVE_col).value)
                        was_inserted = True
                        # Determine how insert the item on bulletin dictionary
                        if str(worksheet.cell(r, patchID_col).value) in bulletin_dict:
                            if worksheet.cell(r, product_col).value.lower() in bulletin_dict[str(worksheet.cell(r, patchID_col).value)]:
                                # Both product name and patch identifier values are yet in bulletin dictionary, so this could be not a new item
                                bulletin_dict[str(worksheet.cell(r, patchID_col).value)][worksheet.cell(r, product_col).value.lower()] =\
                                list(set(bulletin_dict[str(worksheet.cell(r, patchID_col).value)][worksheet.cell(r, product_col).value.lower()] + cve_list))
                            else:
                                # Only patch identifier value is yet in bulletin dictionary, so this is a new item
                                bulletin_dict[str(worksheet.cell(r, patchID_col).value)][worksheet.cell(r, product_col).value.lower()] = cve_list
                        else:
                            # This is a new item, because patch identifier is not in dictionary
                            bulletin_dict[str(worksheet.cell(r, patchID_col).value)] = {}
                            bulletin_dict[str(worksheet.cell(r, patchID_col).value)][worksheet.cell(r, product_col).value.lower()] = cve_list

                elif isGreedy and matchPlatform and not was_inserted:
                    # Searching also on MS components potentially installed on the detetcted OS name [many false positives]
                    if worksheet.cell(r, platform_col).value.lower().startswith(osName):
                        cve_list.append(worksheet.cell(r, CVE_col).value)
                        # Determine how insert the item on bulletin dictionary
                        if str(worksheet.cell(r, patchID_col).value) in bulletin_dict:
                            if worksheet.cell(r, product_col).value.lower() in bulletin_dict[str(worksheet.cell(r, patchID_col).value)]:
                                # Both product name and patch identifier values are yet in bulletin dictionary, so this could be a duplicate
                                bulletin_dict[str(worksheet.cell(r, patchID_col).value)][worksheet.cell(r, product_col).value.lower()] =\
                                list(set(bulletin_dict[str(worksheet.cell(r, patchID_col).value)][worksheet.cell(r, platform_col).value.lower()]+ cve_list))
                            else:
                                # Only patch identifier value is yet in bulletin dictionary, so this is a new item
                                bulletin_dict[str(worksheet.cell(r, patchID_col).value)][worksheet.cell(r, platform_col).value.lower()] = cve_list
                        else:
                            # This is a new item, because patch identifier is not in dictionary
                            bulletin_dict[str(worksheet.cell(r, patchID_col).value)] = {}
                            bulletin_dict[str(worksheet.cell(r, patchID_col).value)][worksheet.cell(r, platform_col).value.lower()] = cve_list

    # Additional research on MS Advisories in order to avoid some false positives
    for adv_k, adv_v in iteritems(known_adv_dict):
        # Create a list of CVEs related to the interesting advisories
        adv_list.append(adv_k)
    # Create a nested dict with CVE, product name and patch identifier values
    for r in range(0, worksheet.nrows):
        was_inserted = False
        if worksheet.cell(r, impact_col).value in ['Remote Code Execution', 'Elevation of Privilege', 'Defense in Depth', 'Security Feature Bypass']:
            matchFamily = re.search(r'(windows)', worksheet.cell(r, family_col).value.lower())
            matchPlatform = re.search(r'(windows)', worksheet.cell(r, platform_col).value.lower())
            if matchFamily:
                if worksheet.cell(r, product_col).value.lower().startswith(osName):
                    was_inserted = True
                    # Checking for a CVE matching to this ADV
                    if worksheet.cell(r, CVE_col).value in adv_list:
                        matching_adv = worksheet.cell(r, CVE_col).value
                        adv_bulletin_dict[str(worksheet.cell(r, patchID_col).value)] = {}
                        adv_bulletin_dict[str(worksheet.cell(r, patchID_col).value)][worksheet.cell(r, product_col).value.lower()] = known_adv_dict[matching_adv]
                    else:
                        unmatching_adv.append(worksheet.cell(r, CVE_col).value)
                        unmatching_adv = list(set(unmatching_adv))

            elif isGreedy and matchPlatform and not was_inserted:
                if worksheet.cell(r, product_col).value.lower().startswith(osName):
                    # Checking for a CVE matching to this ADV
                    if worksheet.cell(r, CVE_col).value in adv_list:
                        matching_adv = worksheet.cell(r, CVE_col).value
                        #print("[+] Found matching Advisory \"%s\", this will be added to the MS Bulletin list." % matching_adv)
                        adv_bulletin_dict[str(worksheet.cell(r, patchID_col).value)] = {}
                        adv_bulletin_dict[str(worksheet.cell(r, patchID_col).value)][worksheet.cell(r, product_col).value.lower()] = known_adv_dict[matching_adv]
                    else:
                        unmatching_adv.append(worksheet.cell(r, CVE_col).value)
                        unmatching_adv = list(set(unmatching_adv))

    # Warning message for Advisories not in the local knowledge base KNOWN_ADV_TOTAL   
    for u_adv in unmatching_adv:
        if u_adv not in KNOWN_ADV_PURGED and u_adv.startswith('ADV'):
            print("[!] WARNING: Found a unmatching Advisory \"%s\" to verify, it could generate a false positive." % u_adv)

    # Merge the dictionaries (Note that they certainly have different keys)
    bulletin_dict.update(adv_bulletin_dict)
    return bulletin_dict




def old_read_bulletin(oldmsdatabaseFile, osName, vulnType, isGreedy):
    """
    Parse old version MS Bulletin file searching only target OS infos
    """
    # First checks for  the existance of the old MS Buletin file
    if not os.path.isfile(oldmsdatabaseFile):
        print("[-] ERROR: Exiting, bulletin file %s is not present." % oldmsdatabaseFile)
        exit(1)
    # Then copy the file into a csv temporary file
    workbook = xlrd.open_workbook(oldmsdatabaseFile, on_demand=True)
    worksheet = workbook.sheet_by_index(0)

    product_col = 6
    CVE_col = 13
    patchID_col = 2
    impact_col = 4
    component_col = 8
    title_col = 5
    old_bulletin_dict = {}
    cve_list = []
    old_cve_list = []

    # Searching for Privilege Escalation only
    if vulnType == 'local':
        # Create a nested dict with CVE, product name and patch identifier values
        for r in range(0, worksheet.nrows):
            # Only two kinds of exploits are considered
            if worksheet.cell(r, impact_col).value == 'Elevation of Privilege':
                matchTitle = re.search(r'(windows)', worksheet.cell(r, title_col).value.lower())
                if matchTitle and not (worksheet.cell(r, component_col).value):
                    if ( (worksheet.cell(r, product_col).value.lower().startswith(osName)) or (worksheet.cell(r, product_col).value.lower().startswith('microsoft '+osName)) ):
                        cve_string = worksheet.cell(r, CVE_col).value
                        # Discard patches without any CVE
                        if cve_string:
                            old_cve_list = cve_string.split(',')
                            old_bulletin_dict[str(worksheet.cell(r, patchID_col).value)] = {}
                            old_bulletin_dict[worksheet.cell(r, patchID_col).value.lower()][worksheet.cell(r, product_col).value.lower()] = list(set(old_cve_list))
                elif isGreedy and (worksheet.cell(r, component_col).value):
                    if ( (worksheet.cell(r, product_col).value.lower().startswith(osName)) or (worksheet.cell(r, product_col).value.lower().startswith('microsoft '+osName)) ):
                        cve_string = worksheet.cell(r, CVE_col).value
                        # Discard patches without any CVE
                        if cve_string:
                            old_cve_list = cve_string.split(',')
                            old_bulletin_dict[str(worksheet.cell(r, patchID_col).value)] = {}
                            old_bulletin_dict[worksheet.cell(r, patchID_col).value.lower()][worksheet.cell(r, product_col).value.lower()] = list(set(old_cve_list))                

    # Searching for Remote Code Execution only
    elif vulnType == 'remote':
        # Create a nested dict with CVE, product name and patch identifier values
        for r in range(0, worksheet.nrows):
            # Only for 2 kinds of exploits are considered
            if worksheet.cell(r, impact_col).value == 'Remote Code Execution':
                matchTitle = re.search(r'(windows)', worksheet.cell(r, title_col).value.lower())
                if matchTitle and not (worksheet.cell(r, component_col).value):
                    #if worksheet.cell(r, product_col).value.lower().startswith(osName):
                    if ( (worksheet.cell(r, product_col).value.lower().startswith(osName)) or (worksheet.cell(r, product_col).value.lower().startswith('microsoft '+osName)) ):
                        cve_string = worksheet.cell(r, CVE_col).value
                        # Discard patches without any CVE
                        if cve_string:
                            old_cve_list = cve_string.split(',')
                            old_bulletin_dict[str(worksheet.cell(r, patchID_col).value)] = {}
                            old_bulletin_dict[worksheet.cell(r, patchID_col).value.lower()][worksheet.cell(r, product_col).value.lower()] = list(set(old_cve_list))
                elif isGreedy and (worksheet.cell(r, component_col).value):
                    if ( (worksheet.cell(r, product_col).value.lower().startswith(osName)) or (worksheet.cell(r, product_col).value.lower().startswith('microsoft '+osName)) ):
                        cve_string = worksheet.cell(r, CVE_col).value
                        # Discard patches without any CVE
                        if cve_string:
                            old_cve_list = cve_string.split(',')
                            old_bulletin_dict[str(worksheet.cell(r, patchID_col).value)] = {}
                            old_bulletin_dict[worksheet.cell(r, patchID_col).value.lower()][worksheet.cell(r, product_col).value.lower()] = list(set(old_cve_list))

    # Searching for main misc vulnerabilities (RCE, PrivEsc, DefInDepth and SecByp)
    else:
        # Create a nested dict with CVE, product name and patch identifier values
        for r in range(0, worksheet.nrows):
            #if worksheet.cell(r, impact_col).value in ['Remote Code Execution', 'Elevation of Privilege', 'Defense in Depth', 'Security Feature Bypass']:
            if worksheet.cell(r, impact_col).value == 'Remote Code Execution' or worksheet.cell(r, impact_col).value == 'Elevation of Privilege':
                matchTitle = re.search(r'(windows)', worksheet.cell(r, title_col).value.lower())
                cve_list = []
                if matchTitle and not (worksheet.cell(r, component_col).value):
                    # Identify the rows matching with OS name
                    if ( (worksheet.cell(r, product_col).value.lower().startswith(osName)) or (worksheet.cell(r, product_col).value.lower().startswith('microsoft '+osName)) ):
                        cve_string = worksheet.cell(r, CVE_col).value
                        # Discard patches without any CVE
                        if cve_string:
                            old_cve_list = cve_string.split(',')
                            for old_cve in old_cve_list:
                                cve_list.append(old_cve)
                            cve_list = list(set(cve_list))
                            # Determine how insert the item on bulletin dictionary
                            if str(worksheet.cell(r, patchID_col).value) in old_bulletin_dict:
                                if worksheet.cell(r, product_col).value.lower() in old_bulletin_dict[str(worksheet.cell(r, patchID_col).value)]:
                                    # Both product name and patch identifier values are yet in bulletin dictionary, so this could be not a new item
                                    old_bulletin_dict[str(worksheet.cell(r, patchID_col).value)][worksheet.cell(r, product_col).value.lower()] =\
                                    list(set(old_bulletin_dict[str(worksheet.cell(r, patchID_col).value)][worksheet.cell(r, product_col).value.lower()]+ cve_list))
                                else:
                                    # Only patch identifier value is yet in bulletin dictionary, so this is a new item
                                    old_bulletin_dict[str(worksheet.cell(r, patchID_col).value)][worksheet.cell(r, product_col).value.lower()] = cve_list
                            else:
                                # This is a new item, because patch identifier is not in dictionary
                                old_bulletin_dict[str(worksheet.cell(r, patchID_col).value)] = {}
                                old_bulletin_dict[str(worksheet.cell(r, patchID_col).value)][worksheet.cell(r, product_col).value.lower()] = cve_list
                elif isGreedy and (worksheet.cell(r, component_col).value):
                    if ( (worksheet.cell(r, product_col).value.lower().startswith(osName)) or (worksheet.cell(r, product_col).value.lower().startswith('microsoft '+osName)) ):
                        cve_string = worksheet.cell(r, CVE_col).value
                        # Discard patches without any CVE
                        if cve_string:
                            old_cve_list = cve_string.split(',')
                            for old_cve in old_cve_list:
                                cve_list.append(old_cve)
                            cve_list = list(set(cve_list))
                            # Determine how insert the item on bulletin dictionary
                            if str(worksheet.cell(r, patchID_col).value) in old_bulletin_dict:
                                if worksheet.cell(r, product_col).value.lower() in old_bulletin_dict[str(worksheet.cell(r, patchID_col).value)]:
                                    # Both product name and patch identifier values are yet in bulletin dictionary, so this could be not a new item
                                    old_bulletin_dict[str(worksheet.cell(r, patchID_col).value)][worksheet.cell(r, product_col).value.lower()] =\
                                    list(set(old_bulletin_dict[str(worksheet.cell(r, patchID_col).value)][worksheet.cell(r, product_col).value.lower()]+ cve_list))
                                else:
                                    # Only patch identifier value is yet in bulletin dictionary, so this is a new item
                                    old_bulletin_dict[str(worksheet.cell(r, patchID_col).value)][worksheet.cell(r, product_col).value.lower()] = cve_list
                            else:
                                # This is a new item, because patch identifier is not in dictionary
                                old_bulletin_dict[str(worksheet.cell(r, patchID_col).value)] = {}
                                old_bulletin_dict[str(worksheet.cell(r, patchID_col).value)][worksheet.cell(r, product_col).value.lower()] = cve_list

    return old_bulletin_dict




def bulletin_filter(bulletin_dict, osName, osRelease, osServicePack, osArch, osPatches):
    """
    Extract a list of CVEs affecting the target OS
    Based on matching Release, Service-Pack, Arch and Security Patches
    """
    filteredCVEs = []
    blacklistedCVEs = []
    purged = []
    purged_bulletin_dict = {}

    # First delete all items corresponding to installed patches on target
    for key1 in bulletin_dict:
        if key1 in osPatches:
            for key2 in bulletin_dict[key1]:
                blacklistedCVEs.append(bulletin_dict[key1][key2])
                purged.append(key1)
    # Avoid duplicate in purged list
    purged = list(set(purged))
    # Delete patched items
    for key_del in purged:
        del bulletin_dict[key_del]
    purged_bulletin_dict = bulletin_dict

    for key1 in purged_bulletin_dict:    
        # Then extract the missing patches for the target OS
        for key2 in purged_bulletin_dict[key1]:
            # Recheck for OS name, this could be unnecessary
            if ( (key2.startswith(osName)) or (key2.startswith('microsoft '+osName)) ):
                os_is_matching = True
                if osRelease: 
                    match = re.search(r'( r| rc|release|rel)[\s]*(\d)', key2)
                    if match:
                        if osRelease != match.group(2):
                            os_is_matching = False
                if osServicePack:
                    match = re.search(r'(sp|pack|pack:)[\s]*(\d)', key2)
                    if match:
                        if osServicePack != match.group(2):
                            os_is_matching = False
                # Implicit 64 bit architecture will be not checked
                if not is_implicit64bit(osName, osRelease):
                    if osArch and (osArch not in key2):
                        # Often in MS Bulletin the 32 bit architecture is not explicited on OS product name 
                        if osArch != '32':
                            os_is_matching = False
                if os_is_matching:
                    filteredCVEs = list(set(filteredCVEs + purged_bulletin_dict[key1][key2]))
    # Finally remove any CVE maching with already deleted CVE, this is needed because of Microsoft Montlhy Rollups and Security Only 
    for blCVE in blacklistedCVEs:
        if blCVE in filteredCVEs:
            filteredCVEs.remove(blCVE)

    return filteredCVEs




def is_implicit64bit(osName, osRelease):
    """
    Check if the OS is an implicit windows 64 bit architecture
    """
    implicit64bit_list = []
    for OS_vers,OS_arch in iteritems(WINDOWS_HISTORY):
        arch_list = WINDOWS_HISTORY[OS_vers]
        # Build the list of OSs having only a 64 bit architecture
        if not (any([True for x in ['32-bit', 'armv7', 'arm64'] if x in arch_list])):
            implicit64bit_list.append(OS_vers)
    implicit64bit_list = list(set(implicit64bit_list))
    # Check if the target OS is in that list
    for imp64bit in implicit64bit_list: 
        if osName and osName in imp64bit.lower():
            if not osRelease:
                return True
            else:
                match = re.search(r'( r| rc|release|rel)[\s]*(\d)', imp64bit.lower())
                if match:
                    if osRelease == match.group(2):
                        return True

    return False




if __name__ == "__main__":
    # User could choose to update MS Bulletin, build the csv database or start the exploit search
    # Set some default values
    vulnType = 'both'
    no_dos = True
    
    args = argument_parser()

    # Update MS Bulletins was selected
    if args.update:
        # Show the Win Exploit Dowser logo
        print(LOGO)
        # Update MS Bulletin list
        if get_bulletin():
            print("[+] MS Bulletin was correctly updated.")
            exit(0)
        else:
            print("[-] ERROR: Failed to update the MS Bulletin.")
            exit(1)

    if args.build:
        # Show the Win Exploit Dowser logo
        print(LOGO)
        # Update the local hidden CVE database, always discarding DoS scripts
        print("[+] Selected to build/update the csv file with hidden CVE exploits, it is useful to decrease false negatives")
        build_hidden_exploitdb(args.build, True, True)
        exit(0)

    # Exploit research was selected
    # First check if the required arguments have been submitted 
    if not args.database:
        print("[-] ERROR: Exiting, you have to specify a MS Bulletin file location [option --database]")
        exit(1)

    if not args.systeminfo and not args.wmicinfo and not args.target:
        print("[-] ERROR: Exiting, you have to specify source file for OS target infos [options --systeminfo or --wmicinfo]")
        exit(1)

    # Show the Win Exploit Dowser logo
    print(LOGO)

    # The required arguments aquired, and from here the trip begins...
    if args.crash:
        print("[!] WARNING: Searching also.exploits that can cause Denial of Service.")
        no_dos = False

    if args.database:
        msdatabase_file = args.database

    # Extract the bulletin infos for the target OS
    if args.systeminfo:
        # Target OS infos will be extracted from sysinfo file
        osName,osRelease,osServicePack,osArch,osPatches = read_systeminfo(args.systeminfo)
    elif args.wmicinfo:
        # Target OS infos will be extracted from wmicinfo file
        if not args.target:
            print("[-] ERROR: Exiting, when using wmicinfo file you have to insert manually the OS target characteristics [using the --target option].")
            exit(1)
        else:
            osInputString = args.target
            osName,osRelease,osServicePack,osArch,osPatches = read_wmicinfo(args.wmicinfo, osInputString)
    elif args.target and not args.wmicinfo and not args.systeminfo:
        # Target OS infos will be extracted from user input string
        osInputString = args.target
        osName,osRelease,osServicePack,osArch = parse_targetinput(osInputString)
        osPatches = []

    # Retrieve Exploit as dict of CVE and related file-path values
    updatedExploits = update_exploits(args.exploitdb_dir, args.meta_dir, no_dos)
    localDB = update_local_dict(updatedExploits)

    print("[*] Extracting bulletin infos for the target OS...")
    if args.local:
        vulnType = 'local'
        print("[+] Only Privilege Escalation vulnerabilities were selected.")
    elif args.remote:
        vulnType = 'remote'
        print("[+] Only Remote Code Execution vulnerabilities were selected.")
    else:
        print("[+] Both Privilege Escalation and Remote Code Execution vulnerabilities were selected.")

    # Retrieve the security patch infos from MS Bulletin files
    if not os.path.isfile(OLD_MSBULLETIN_FILE):
        print("[!] WARNING: Missing old MS bulletin file \"%s\", so trying to download it." % OLD_MSBULLETIN_FILE)
        if not get_old_bulletin():
            print("[-] ERROR: Exiting, it was not possible to retrieve the needed old MS BULLETIN file.")
            exit(1)

    # Check if was selected a greedy patch search (many flase positives) or a strict patch search
    if args.greedy:
        print("[!] WARNING: Searching security patches also for MS components, this could lead more false positives.")
        bulletinInfos = read_bulletin(msdatabase_file, osName, vulnType, True)
        old_bulletinInfos = old_read_bulletin(OLD_MSBULLETIN_FILE, osName, vulnType, True)
    else:
        bulletinInfos = read_bulletin(msdatabase_file, osName, vulnType, False)
        old_bulletinInfos = old_read_bulletin(OLD_MSBULLETIN_FILE, osName, vulnType, False)

    # Retrieve the list of CVE affecting the target OS
    affectingCVEs = bulletin_filter(bulletinInfos, osName, osRelease, osServicePack, osArch, osPatches)
    old_affectingCVEs = bulletin_filter(old_bulletinInfos, osName, osRelease, osServicePack, osArch, osPatches)

    # Merge the lists of found affecting CVEs
    affectingCVEs = list(set(affectingCVEs + old_affectingCVEs))

    # Show the complete list of unpatched CVEs
    if args.verbose:
        index = 1
        print("[+] List of unpatched CVEs:")
        for aCVE in affectingCVEs:
            print("\033[1;33;49m[" + str(index) + "] %s" % aCVE)
            index += 1

    workingExploits = {}
    # Finally identify the possible working exploits to use
    for aCVE in affectingCVEs:
        for eCVE,fpath in iteritems(localDB):
            if aCVE == eCVE:
                workingExploits[aCVE] = fpath

    print("\033[0;39;49m[+] Found %d security patches installed on target OS." % len(osPatches))
    printable_str = print_str(osName.title(), osRelease, osServicePack, osArch)
    print("\033[0;39;49m[+] Found %d CVEs with known exploits to use against the target OS \"%s\" [Legenda: E = exploitDB; M = Metasploit; O = Others]:" % (len(workingExploits), printable_str))
    #print("=======================================================================================")
    for wCVE,wfpath in iteritems(workingExploits):
        for wfp in wfpath:
            medb = re.search(r'(exploitdb)', wfp.lower())
            mmeta = re.search(r'(metasploit)', wfp.lower())
            if medb:
                print("\033[1;32;49m[E] Vulnerability %s ---> Exploit %s" % (wCVE, wfp))
            elif mmeta:
                print("\033[1;31;49m[M] Vulnerability %s ---> Exploit %s" % (wCVE, wfp))
            else:
                print("\033[1;35;49m[O] Vulnerability %s ---> Exploit %s" % (wCVE, wfp))


